# 缓存策略

Web缓存的作用：
- 减少网络带宽消耗
- 降低服务器压力
- 减少网络延迟，加快页面打开速度

现有缓存策略大致有以下几类：
- 浏览器缓存
    - HTTP缓存
        - 协商缓存阶段
            - `Last-modified` & `If-Modified-Since`
            - `ETag` & `If-None-Match`
        - 本地缓存阶段
            - `Cache-Control`
            - `Expires`
- 服务器缓存
    - CDN缓存
    - Combo服务
- HTML5缓存思路
    - 离线存储`manifest`
    - 本地存储`localStorage`

## 浏览器端的缓存规则

对于浏览器端的缓存来讲，这些规则是在HTTP协议头和HTML页面的Meta标签中定义的。他们分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取更新的版本。

新鲜度（过期机制）：也就是缓存副本有效期。一个缓存副本必须满足以下条件，浏览器会认为它是有效的，足够新的：

- 含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内；
- 浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度

满足以上两个情况的一种，浏览器会直接从缓存中获取副本并渲染。

校验值（验证机制）：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容。

### 关键概念
`缓存命中率`：一个缓存的有效性是依照缓存的命中率来度量。它是根据得到数据请求次数与所有请求次数的比率。缓存命中率高意味着有很高的比率数据是从缓存中获取到数据的。
    
### HTTP缓存机制
缓存行为主要由缓存策略决定，而缓存策略由内容拥有者设置。这些策略主要通过特定的HTTP头部来清晰地表达。

当一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取资源：

- 本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器；
- 协商缓存阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；
- 缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回404。 

### 缓存相关http消息报头

| 规则 | 消息头 | 值 | 示例 | 类型 | 作用 |
| 新鲜度 | Expires Sun, 16 Oct 2016 05:43:02 GMT | 响应 | 告诉浏览器在过期时间前可以使用副本（有可能存在时间不一致问题）|
||Pragma | no-cache | 响应 | 告诉浏览器忽略资源的缓存副本(HTTP1.1 可用 Cache-Control替换 |
||Cache-Control | no-cache | 响应 | 告诉浏览器忽暇资源的缓存副本，强制每次请求直接发送给源眼务器|
|||no-store | 响应 | 强制缓存在任何情况下都不要保留任何副本|
|||max-age=\[秒\] | 响应 | 指明副本的有效时长，从请求时间开始到过期时间之间的秒数|
|||public | 响应 | 任何途经的缓存者（本地緩存，代理眼务器）可以无条件的缓存该资源|
|||private | 响应 | 只针对单个用户越体（不同用户，窗口）缓存资源|
||Last-Modified | Sun, 16 Oct 2016 05:43:02 GMT | 响应 | 浏览器当前资源的多改时间|
||If-ModifiedSince| Sun, 16 Oct 2016 05:43:02 GMT | 请求 | 如果浏览器第一次请求时响应中Last-Modified非空，第二请求同一资源时，会把它作为该项的值发给服务器
|校验值 | ETag | 50blcld4f775c61:df3 | 响应 | 告知浏览器当前资源在服务器的唯一标识符（生成规则由服务器决定）|
||If-None-Match | 50blcld4f775c61:df3 | 请求 | 如果浏览器第一次请求时响应中Etag非空，第二次请求同一资源时，会把它作为该项的值发送给服务|
|辅助 | Vary | Accept-Encoding | 响应 | 辅助从多个缓存副本中筛选合适的版本（不同压缩算法产生的副本）|

### 用户操作行为与缓存

|用户操作 |Expires/Cache-Control |Last-Modified/Etag|
|地址栏回车| 有 效 | 有 效|
|页面链接跳转| 有 效 |有 效|
|新开窗口| 有 效 |有 效|
|前进后退| 有 效 |有 效|
|F5刷新| 无 效 |有 效|
|Ctrl+F5强制刷新| 无 效|无 效|

浏览器中的操作对缓存的影响:

- 强制刷新 – 当按下ctrl+F5来刷新页面的时候, 浏览器将绕过各种缓存(本地缓存和协商缓存), 直接让服务器返回最新的资源;
- 普通刷新 – 当按下F5来刷新页面的时候,浏览器将绕过本地缓蹲来发送请求到服务器, 此时, 协商缓存是有效的
- 回车或转向 – 当在地址栏上输入回车或者按下跳转按钮的时候, 所有缓存都生效

### 本地缓存阶段

Last-Modified & if-modified-since：
- Last-Modified与If-Modified-Since是一对报文头，属于http 1.0。
- last-modified是WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间。

ETag & If-None-Match：
- ETag与If-None-Match是一对报文，属于http 1.1。
- ETag是一个文件的唯一标志符。就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化。
- ETag机制类似于乐观锁机制，如果请求报文的ETag与服务器的不一致，则表示该资源已经被修改过来，需要发最新的内容给浏览器。
- 同时使用这两个报文头，在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，如都与服务器的相符，服务器返回304，否则，发送最新内容给浏览器。

Etag/lastModified过程如下：
1. 客户端请求一个页面（A）。
2. 服务器返回页面A，并在给A加上一个Last-Modified/ETag。
3. 客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。
4. 客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。
5. 服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。
